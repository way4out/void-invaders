<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
  <title>Void Invaders: Galactic Grind</title>
  <meta name="theme-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- RainbowKit & Wagmi for Wallet Connect -->
  <script src="https://unpkg.com/@rainbow-me/rainbowkit@2.5.3/dist/index.js"></script>
  <script src="https://unpkg.com/wagmi@2.13.4/dist/index.js"></script>
  <script src="https://unpkg.com/viem@2.28.4/dist/index.js"></script>
  <script src="https://unpkg.com/@tanstack/react-query@5.59.0/build/index.umd.js"></script>

  <!-- Zora Protocol SDK for Minting -->
  <script src="https://unpkg.com/@zoralabs/protocol-sdk@2.3.1/dist/index.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&display=swap');
    * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    body {
      background: radial-gradient(circle at center, #000428 0%, #004e92 100%);
      color: #00ff00;
      font-family: 'Orbitron', 'Courier New', monospace;
      overflow: hidden;
      touch-action: manipulation;
      height: 100vh;
      display: flex;
      flex-direction: column;
      animation: pulse 4s ease-in-out infinite alternate;
    }
    @keyframes pulse {
      0% { background: radial-gradient(circle at center, #000428 0%, #004e92 100%); }
      100% { background: radial-gradient(circle at center, #004e92 0%, #000428 100%); }
    }
    #ui {
      padding: 8px;
      text-align: center;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(10px);
      z-index: 10;
      flex-shrink: 0;
      box-shadow: 0 0 20px #00ff00;
    }
    #prices { font-size: 11px; margin: 4px 0; opacity: 0.9; }
    #gameInfo { font-size: 13px; margin: 6px 0; }
    #leaderboard {
      font-size: 10px;
      max-height: 100px;
      overflow-y: auto;
      background: rgba(0,255,0,0.1);
      padding: 5px;
      border: 1px solid #00ff00;
      margin: 5px 0;
    }
    #canvas {
      flex: 1;
      width: 100vw;
      image-rendering: pixelated;
      touch-action: none;
      filter: contrast(1.2) brightness(1.1);
    }
    #controls {
      display: flex;
      justify-content: space-between;
      padding: 12px;
      background: rgba(0,20,0,0.9);
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 20;
      box-shadow: 0 -5px 20px #00ff00;
    }
    .btn {
      background: linear-gradient(45deg,#00ff00,#008800);
      color: #000;
      border: none;
      padding: 14px 20px;
      margin: 0 8px;
      border-radius: 50px;
      font-weight: bold;
      font-size: 14px;
      flex: 1;
      max-width: 140px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover, .btn:active {
      transform: scale(1.05);
      box-shadow: 0 0 15px #00ff00;
    }
    #mintBtn { background: linear-gradient(45deg,#ff00ff,#aa00aa); }
    #fireBtn {
      background: radial-gradient(#ffff00,#ff8800);
      border-radius: 50%;
      width: 80px; height: 80px;
      font-size: 32px;
      position: absolute;
      right: 20px;
      bottom: 80px;
      border: none;
      color: #000;
    }
    #joystick {
      width: 120px; height: 120px;
      background: rgba(0,255,0,0.15);
      border: 3px solid #00ff00;
      border-radius: 50%;
      position: absolute;
      left: 20px;
      bottom: 70px;
      transition: box-shadow 0.2s;
    }
    #joystick.active { box-shadow: 0 0 20px #00ff00; }
    #knob {
      width: 50px; height: 50px;
      background: #00ff00;
      border-radius: 50%;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      transition: none;
    }
    a { color:#00ff00; text-decoration:none; }
    .token-link:hover { text-shadow: 0 0 10px #00ff00; }
    #connectWallet { background: #00ffff; color: #000; padding: 10px; border-radius: 5px; cursor: pointer; }
    #treasury { font-size: 10px; color: #ffff00; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&display=swap" rel="stylesheet">
</head>
<body>

  <div id="ui">
    <h1 style="font-size:5vw;margin:0;">Void Invaders</h1>
    <div id="prices">
      <a href="https://base.app/coin/base-mainnet/0xeedd6ec4fcebed881fc2994507e2c481a6c5eac3" target="_blank" class="token-link">$4out</a> <span id="fourout">$0.0001</span> |
      <a href="https://base.app/coin/base-mainnet/0xf097454f9874ce870d0d4cd8d419c3de4e63197e" target="_blank" class="token-link">$A1i3N</a> <span id="a1ien">$0.0005</span> |
      <a href="https://base.app/coin/base-mainnet/0x4deeba0fca2f9a8b307b891241eac57b6bf713ec" target="_blank" class="token-link">$COIN4</a> <span id="coin4">$0.0045</span> |
      <a href="https://base.app/coin/base-mainnet/0x98a8165a44782ab43c378ed9f501d55ec51b2880" target="_blank" class="token-link">$TR3B</a> <span id="tr3b">$0.0008</span>
    </div>
    <div id="gameInfo">
      Wallet: <span id="wallet" style="cursor:pointer;color:#00ffff;" onclick="connectWallet()">Tap to Connect</span><br>
      Shards: <span id="score">0</span> | Wave <span id="wave">1</span> | Kills <span id="kills">0</span>
    </div>
    <div id="treasury">Treasury ($4out): 1,569,471 | All revenue → 0xCeA57eEdA6eF19ce51caBE00e4CF425a31802D74</div>
    <div id="leaderboard">
      <strong>Leaderboard:</strong><br>
      <div id="lbList">Loading...</div>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div id="controls">
    <button class="btn" id="mineBtn">MINE</button>
    <button class="btn" id="redeemBtn">REDEEM</button>
    <button class="btn" id="mintBtn">MINT NFT</button>
  </div>

  <!-- Touch Controls -->
  <div id="joystick"><div id="knob"></div></div>
  <button id="fireBtn">FIRE</button>

  <script>
    // === WALLET CONNECT WITH RAINBOWKIT/WAGMI ===
    const { getDefaultConfig } = RainbowKit;
    const { WagmiProvider, createConfig, http } = wagmi;
    const { QueryClient, QueryClientProvider } = TanStackQueryDevtools;

    const base = {
      id: 8453,
      name: 'Base',
      network: 'base',
      nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      rpcUrls: { default: { http: ['https://mainnet.base.org'] } },
      blockExplorers: { default: { name: 'Basescan', url: 'https://basescan.org' } },
    };
    const config = createConfig({
      chains: [base],
      transports: { [base.id]: http() },
    });

    let connectedAddress = null;

    async function connectWallet() {
      if (window.ethereum) {
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          connectedAddress = accounts[0];
          document.getElementById('wallet').textContent = connectedAddress.slice(0,6) + '...' + connectedAddress.slice(-4);
          loadLeaderboard();
          initZora();
          alert('Wallet Connected on Base!');
        } catch (error) {
          console.error('Connection failed:', error);
        }
      } else {
        alert('Install MetaMask or compatible wallet!');
      }
    }

    // === ZORA MINT BUTTON (Revenue to Treasury Wallet) ===
    const ZORA_SDK = ZoraProtocolSDK;
    let zoraClient;
    async function initZora() {
      if (!connectedAddress) return;
      zoraClient = await ZoraProtocolSDK.initialize({
        chainId: 8453, // Base
      });
    }

    const TREASURY_WALLET = '0xCeA57eEdA6eF19ce51caBE00e4CF425a31802D74';
    async function mintNFT(shards) {
      if (!zoraClient || shards < 150) return alert('Need 150+ shards & connected wallet!');
      try {
        // Mint to player, but royalties (revenue) flow to treasury via Zora collection setup
        const mintArgs = {
          chain: 'base',
          contractAddress: '0xYourNewZoraCollectionAddress', // Replace with your new Zora collection on Base
          tokenId: BigInt(Math.floor(Math.random() * 10000) + Date.now() % 1000), // Unique per mint
          quantity: '1',
          to: connectedAddress,
          // Royalties auto to creator (your wallet) on Zora - revenue reflects in ZORA balance or ETH
        };
        const { requests } = await zoraClient.mint.prepare(mintArgs);
        const tx = await zoraClient.mint.execute(requests[0]);
        alert(`Zora NFT Minted! Tx: ${tx.hash}\nRevenue → Treasury: ${TREASURY_WALLET}`);
        score -= 150;
        // Optional: Airdrop small $4out from treasury as bonus
        await airdropBonus(connectedAddress, 100); // 100 $4out from treasury
      } catch (error) {
        console.error('Mint failed:', error);
        alert('Mint failed - check console. Ensure Zora collection is set up with royalties to ' + TREASURY_WALLET);
      }
    }

    // === TOKEN AIRDROP FROM TREASURY (Revenue Reflection) ===
    const FOUR_OUT_ABI = ['function transfer(address to, uint256 amount)'];
    const FOUR_OUT_ADDRESS = '0xeedd6ec4fcebed881fc2994507e2c481a6c5eac3';
    async function airdropBonus(to, amount) {
      if (connectedAddress !== TREASURY_WALLET) { // Only treasury can airdrop
        return;
      }
      try {
        const tx = await window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [{
            from: TREASURY_WALLET,
            to: FOUR_OUT_ADDRESS,
            data: '0xa9059cbb' + to.slice(2).padStart(64, '0') + amount.toString(16).padStart(64, '0'), // transfer calldata
          }],
        });
        await tx.wait();
        console.log(`Airdropped ${amount} $4out to ${to}`);
      } catch (error) {
        console.error('Airdrop failed:', error);
      }
    }

    // === REDEEM (Tokens from Treasury) ===
    async function redeemTokens(shards) {
      if (!connectedAddress) return alert('Connect wallet!');
      const rates = { fourout: shards / 50, a1ien: shards / 100, coin4: shards / 150, tr3b: shards / 200 };
      // Simulate multicall transfer from treasury
      console.log(`Redeeming: $4out=${Math.floor(rates.fourout)}, $A1i3N=${Math.floor(rates.a1ien)}, etc. to ${connectedAddress}`);
      await airdropBonus(connectedAddress, Math.floor(rates.fourout)); // Example for $4out
      alert(`Tokens redeemed! Check your Base wallet.\nRevenue tracked in Treasury ZORA/ETH balance.`);
    }

    // === LEADERBOARD (On-Chain) ===
    const LB_ABI = [
      'function submitScore(address player, uint256 score) external',
      'function getTopScores() view returns (tuple(address,uint256)[] memory)'
    ];
    const LB_ADDRESS = '0xYourLeaderboardContractAddress'; // Deploy & replace

    async function submitScore() {
      if (!connectedAddress || kills === 0) return;
      try {
        // Placeholder - in prod, sign & send
        console.log(`Submitted score ${kills * 10} for ${connectedAddress}`);
        loadLeaderboard();
      } catch (error) {
        console.error('Submit failed:', error);
      }
    }

    async function loadLeaderboard() {
      try {
        // Placeholder data - replace with real readContract
        const topScores = [
          { player: '0x123...', score: 5000 },
          { player: '0x456...', score: 4200 },
        ];
        document.getElementById('lbList').innerHTML = topScores.map((s, i) => `<div>${i+1}. ${s.player} : ${s.score} shards</div>`).join('');
      } catch (error) {
        document.getElementById('lbList').textContent = 'Deploy LB contract to enable!';
      }
    }

    // === GAME LOGIC ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let w, h;

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight - document.getElementById('ui').offsetHeight - 80;
    }
    window.onresize = resize; resize();

    let score = 0, kills = 0, wave = 1, mining = false;
    const player = { x: w/2, y: h-80, w: 40, h: 30, speed: 8, glow: 0 };
    let enemies = [], bullets = [], particles = [], stars = [];

    // Stars
    for (let i = 0; i < 200; i++) {
      stars.push({ x: Math.random() * w, y: Math.random() * h, size: Math.random() * 2, speed: Math.random() * 0.5 + 0.1 });
    }

    // Touch
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('knob');
    let touchId = null, baseX, baseY;

    joystick.addEventListener('touchstart', e => {
      if (touchId) return;
      const t = e.changedTouches[0];
      touchId = t.identifier;
      baseX = t.clientX; baseY = t.clientY;
      joystick.classList.add('active');
      e.preventDefault();
    });

    document.addEventListener('touchmove', e => {
      if (!touchId) return;
      for (let t of e.changedTouches) {
        if (t.identifier === touchId) {
          const dx = Math.max(-60, Math.min(60, t.clientX - baseX)) / 3;
          const dy = Math.max(-60, Math.min(60, t.clientY - baseY)) / 3;
          player.x = Math.max(20, Math.min(w-60, w/2 + dx));
          knob.style.transform = `translate(${dx}px, ${dy}px)`;
          break;
        }
      }
      e.preventDefault();
    });

    document.addEventListener('touchend', e => {
      for (let t of e.changedTouches) {
        if (t.identifier === touchId) {
          touchId = null;
          knob.style.transform = 'translate(-50%,-50%)';
          joystick.classList.remove('active');
        }
      }
    });

    document.getElementById('fireBtn').addEventListener('touchstart', e => {
      shoot();
      e.preventDefault();
    });

    // Keys
    const keys = {};
    document.addEventListener('keydown', e => { 
      keys[e.key.toLowerCase()] = true; 
      if (e.key === ' ') { e.preventDefault(); shoot(); } 
    });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    function beep(f=440,d=80){ 
      try {
        const a = new AudioContext();
        const o = a.createOscillator();
        const g = a.createGain();
        o.connect(g); g.connect(a.destination);
        o.frequency.value = f; o.start();
        g.gain.exponentialRampToValueAtTime(0.01, a.currentTime + d/1000);
        o.stop(a.currentTime + d/1000);
      } catch {}
    }

    function shoot() {
      bullets.push({x: player.x + player.w/2 - 2, y: player.y, w:4, h:12, s:12, glow: 20});
      beep(800, 60);
    }

    function spawnEnemy() {
      const type = Math.random() < 0.35 ? 'a1ien' : 'basic';
      enemies.push({
        x: Math.random() * (w - 50) + 25,
        y: -40,
        w: 40, h: 30,
        s: 1 + wave * 0.4,
        type,
        glow: type === 'a1ien' ? 30 : 15
      });
    }

    function drawGlow(x, y, radius, color, blur = 20) {
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
      gradient.addColorStop(0, color + 'FF');
      gradient.addColorStop(1, color + '00');
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function update() {
      if (keys['arrowleft'] || keys['a']) player.x -= player.speed;
      if (keys['arrowright'] || keys['d']) player.x += player.speed;
      player.x = Math.max(10, Math.min(w - player.w - 10, player.x));
      player.glow = Math.min(player.glow + 1, 30);

      if (Math.random() < 0.03 + wave * 0.01) spawnEnemy();

      bullets = bullets.filter(b => {
        b.y -= b.s;
        b.glow = Math.max(0, b.glow - 1);
        return b.y > -20;
      });

      enemies = enemies.filter((e) => {
        e.y += e.s;
        e.x += Math.sin(Date.now() * 0.001 + e.y) * 2;
        if (Math.random() < 0.01 + wave * 0.005) {
          bullets.push({x: e.x + e.w/2, y: e.y + e.h, w:4, h:10, s: -6, glow: 10});
          beep(200, 40);
        }
        if (e.y > h + 20) { gameOver(); return false; }
        return true;
      });

      // Collisions
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        for (let ei = enemies.length - 1; ei >= 0; ei--) {
          const e = enemies[ei];
          if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
            for (let i = 0; i < 20; i++) {
              particles.push({
                x: e.x + e.w/2,
                y: e.y + e.h/2,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                life: 1,
                color: e.type === 'a1ien' ? '#ff00ff' : '#ff0066',
                glow: 15
              });
            }
            enemies.splice(ei, 1);
            bullets.splice(bi, 1);
            score += e.type === 'a1ien' ? 40 : 10;
            kills++;
            if (kills % 12 === 0) wave++;
            beep(600, 80);
            submitScore();
            break;
          }
        }
      }

      // Enemy hits player
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        if (b.s < 0 && b.x > player.x && b.x < player.x + player.w && b.y > player.y && b.y < player.y + player.h) {
          for (let i = 0; i < 15; i++) {
            particles.push({
              x: player.x + player.w/2,
              y: player.y + player.h/2,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              life: 1,
              color: '#00ff00',
              glow: 10
            });
          }
          bullets.splice(bi, 1);
          gameOver();
          break;
        }
      }

      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.03;
        p.glow = p.life * 20;
        return p.life > 0;
      });

      if (mining) score += 0.15;

      document.getElementById('score').textContent = Math.floor(score);
      document.getElementById('wave').textContent = wave;
      document.getElementById('kills').textContent = kills;

      // Prices
      setTimeout(() => {
        document.getElementById('fourout').textContent = '$' + (0.0001 + Math.random() * 0.0001).toFixed(4);
        document.getElementById('a1ien').textContent = '$' + (0.0005 + Math.random() * 0.0004).toFixed(4);
        document.getElementById('coin4').textContent = '$' + (0.0045 + Math.random() * 0.001).toFixed(4);
        document.getElementById('tr3b').textContent = '$' + (0.0008 + Math.random() * 0.0002).toFixed(4);
      }, 3000);

      requestAnimationFrame(update);
    }

    function draw() {
      ctx.fillStyle = 'rgba(0, 4, 40, 0.1)';
      ctx.fillRect(0, 0, w, h);

      stars.forEach(s => {
        s.y += s.speed;
        if (s.y > h) s.y = 0;
        const twinkle = Math.sin(Date.now() * 0.005 + s.x) * 0.5 + 0.5;
        drawGlow(s.x, s.y, s.size * twinkle + 1, '#ffffff', 5);
      });

      drawGlow(player.x + player.w/2, player.y + player.h/2, player.glow, '#00ff00', 15);
      ctx.fillStyle = '#00ff00';
      ctx.beginPath();
      ctx.moveTo(player.x + player.w/2, player.y);
      ctx.lineTo(player.x, player.y + player.h);
      ctx.lineTo(player.x + player.w, player.y + player.h);
      ctx.closePath();
      ctx.fill();

      bullets.forEach(b => {
        drawGlow(b.x + b.w/2, b.y + b.h/2, b.glow, '#ffff00', 10);
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(b.x, b.y, b.w, b.h);
      });

      enemies.forEach(e => {
        drawGlow(e.x + e.w/2, e.y + e.h/2, e.glow, e.type === 'a1ien' ? '#ff00ff' : '#ff0066', 20);
        ctx.fillStyle = e.type === 'a1ien' ? '#ff00ff' : '#ff0066';
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(e.x + 8, e.y + 8, 6, 6);
        ctx.fillRect(e.x + 26, e.y + 8, 6, 6);
        if (e.type === 'a1ien') {
          ctx.strokeStyle = '#ff00ff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(e.x + 10, e.y + e.h);
          ctx.lineTo(e.x + 10, e.y + e.h + 20);
          ctx.moveTo(e.x + 30, e.y + e.h);
          ctx.lineTo(e.x + 30, e.y + e.h + 20);
          ctx.stroke();
        }
      });

      particles.forEach(p => {
        drawGlow(p.x, p.y, p.glow, p.color, p.glow);
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
      });
      ctx.globalAlpha = 1;

      requestAnimationFrame(draw);
    }

    function gameOver() {
      alert(`VOID BREACHED\nShards: ${Math.floor(score)}\nWave ${wave} | Kills ${kills}\nRedeem or Mint to earn from Treasury!`);
      location.reload();
    }

    // Buttons
    document.getElementById('mineBtn').onclick = () => {
      if (!connectedAddress) return alert('Connect wallet!');
      mining = !mining;
      this.textContent = mining ? 'MINING...' : 'MINE';
      beep(400);
    };
    document.getElementById('redeemBtn').onclick = () => redeemTokens(score);
    document.getElementById('mintBtn').onclick = () => mintNFT(score);

    // Init
    loadLeaderboard();
    update();
    draw();
  </script>
</body>
</html>
